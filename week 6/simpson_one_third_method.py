# 2.3 Simpson's One-Third Rule (Numerical Integration)
# ∫f(x)dx ≈ (h/3)[f(x_0) + 4f(x_1) + 2f(x_2) + 4f(x_3) + ... + 4f(x_{n-1}) + f(x_n)]
#
# ОПИСАНИЕ:
# Правило Симпсона 1/3 — аппроксимирует функцию параболой (квадратичным
# полиномом) на каждой паре интервалов. Берутся три точки: x_i, x_{i+1}, x_{i+2},
# через них проводится единственная парабола, и интеграл по ней считается точно.
# Название "1/3" — от коэффициента h/3 в формуле.
#
# Требования: чётное число интервалов (нечётное число точек: 3, 5, 7, ...).
# Погрешность: O(h⁴) — метод четвёртого порядка, точнее трапеций.
# Коэффициенты: чередуются 1, 4, 2, 4, 2, ..., 4, 1 (концы — 1, нечётные — 4, чётные — 2).


# --- ФУНКЦИЯ ВЫЧИСЛЕНИЯ ИНТЕГРАЛА ---
def simpson_one_third(x_nodes, y_nodes):
    """Simpson's 1/3 rule: ∫f ≈ (h/3)[y_0 + 4y_1 + 2y_2 + 4y_3 + ... + y_n]"""
    # Проверка: нужно чётное число интервалов (нечётное число точек)
    n = len(y_nodes)
    if (n - 1) % 2 != 0:
        raise ValueError("Simpson 1/3 needs odd # of points (even # of intervals)")

    # Шаг h — расстояние между соседними узлами
    h = x_nodes[1] - x_nodes[0]

    # Взвешенная сумма: y_0 + y_n + 4*(y_1+y_3+...) + 2*(y_2+y_4+...)
    result = y_nodes[0] + y_nodes[-1]
    for i in range(1, n - 1):
        result += (4 if i % 2 == 1 else 2) * y_nodes[i]

    # Итоговый интеграл = (h/3) * сумма
    return (h / 3) * result


# Демонстрация работы метода (запускается при прямом вызове файла)
if __name__ == "__main__":
    # Тестовые данные: y = x² + 1, ∫(x²+1)dx от 1 до 4 = 24
    x_simp = [1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0]
    y_simp = [2.0, 3.25, 5.0, 7.25, 10.0, 13.25, 17.0]

    # Вывод заголовка и входных данных
    print("--- 2.3 Simpson's One-Third Rule ---")
    print(f"Data: x = {x_simp}, y = {y_simp}")
    print(f"h = {x_simp[1] - x_simp[0]}")

    # Вычисление интеграла и вывод результата
    result = simpson_one_third(x_simp, y_simp)
    print(f"∫f dx ≈ {result:.6f}")
    print("True value: 24.0")
